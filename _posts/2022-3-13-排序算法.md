---
title: 排序算法
tags: 算法
article_header:
  type: cover
  image:
    src: /img/dataStruct/bg.jpeg
---

**插入排序(直接插入排序、折半插入排序、希尔排序)**

一起学习:smiley:



<!--more-->

---



# 插入排序

## 直接插入排序

**逻辑简述：**

打扑克牌一张一张抓牌排序的原理

拿起一张，插入到手牌中合适的位置

![](https://pic.imgdb.cn/item/622d65fe5baa1a80ab14b79d.gif)

```c
#include<stdio.h>

#define SIZE 13

/**
 * 直接插入排序
 * @param a
 * @param size
 */
void directInsertSort(int *a, int size) {
    int j, k, tmp;

    //循环遍历整个数组
    for (int i = 0; i < size; ++i) {

        //遍历手牌 j = i - 1 ~ 0 ,i是现在摸的牌待插入的
        for (j = i - 1; j >= 0; --j) {//这里的j设计！！
            //待插入的牌大于手牌就保留位置退出
            //这里的保留位置体现在j是作用域
            if (a[i] > a[j])//a[i]是待插入的牌
                break;
        }

//        获取了待插入的空位，由于是--j，所以后续插入要+1
//        printf("j = %d\n",j);

        //插入
        //判断是不是最后一位数，是的话就不用插入了
        //也就是如果待插入的手牌都大于排序好的手牌中最后一位了，那就不用动了
        if (j != i - 1) {
            //遍历手牌
            tmp = a[i];//保存待插入的手牌
            //向后移动
            //为什么不是k >= j，因为j在上次退出for循环时--了
            for (k = i - 1; k >= j+1; --k) {//for只能保证k在for中>j
                //向后移动
                a[k + 1] = a[k];
//                printf("k = %d\n",k);
            }
            //找到之前需要插入的位置
            a[j + 1] = tmp;
        }

//        for (int i = 0; i < 13; ++i) {
//            printf("%d ", a2[i]);
//        }
//        printf("\n");
    }

    //遍历输出
    for (int i = 0; i < size; ++i) {
        printf("%d ", a[i]);
    }
}

int main(int argc, char *argv[]) {
    int a[SIZE] = {23, 4, 56, 7, 8, 9, 8, 76, 5, 4, 34, 5, 6};
    
//    直接插入排序
    printf("直接插入排序:\n");
    directInsertSort(a, SIZE);
    printf("\n");
}
```

**设计的难点：**

1. 找手牌

```c
for (j = i - 1; j >= 0; --j) {     
   if (a[i] > a[j])
     break;
}
```

确定位置**j+1**

1. 向后挪动

```c
for (k = i - 1; k > j; --k) {
   a[k + 1] = a[k];
}
```

插入

```c
a[j + 1] = tmp;
```



**Go实现**

```go
package main

import "fmt"

//定义一个待排序的数组
var a1 = [13]int{23, 94, 6, 92, 6, 5, 9, 3, 2, 59, 8, 1, 2}

func directInsertSort(a *[len(a1)]int, size int) {

	var j, k, tmp int

	//整体遍历循环
	for i := 0; i <= size-1; i++ {
		//线性查找待排序的位置
		for j = i - 1; j >= 0; j-- {
			if a[i] > a[j] {
				break
			}
		}

		//待插入的位置是 j+1

		//向后移动
		if j != i-1 { //待牌 < 所有的手牌就需向后移动
			//保存手牌,避免移动时被覆盖
			tmp = a[i]
			//向后移动
			for k = i - 1; k >= j+1; k-- {
				a[k+1] = a[k]
			}

			//插入
			a[j+1] = tmp
		}
	}

	for _, v := range a {
		fmt.Printf("%d ", v)
	}
}

func main() {
	directInsertSort(&a1, len(a1))
}
```

```
1 2 2 3 5 6 6 8 9 23 59 92 94 
```



## 折半插入排序

在直接插入上做了优化，查找需要插入的位置时，用了二分查找(原先时线性查找)

```c
#include<stdio.h>

#define SIZE 13

/**
 * 折半插入
 * @param a
 * @param size
 */
void halfInsertSort(int *a, int size, int v) {
    int left = 0;
    int right = size - 1;
    int mid;

    //1.二分查找
    while (left <= right) {
        mid = (left + right) / 2;

        if (v > a[mid]){
            left = mid + 1;
        } else{
            right = mid -1;
        }
    }
//  分许二分查找结束后需要插入的位置，见后图
//  right+1就是v要插入的位置,因为right会多减少一次

    //2.向后挪
    for (int i = size-1; i >= right+1; --i) {
        a[i+1] = a[i];
    }

    a[right+1] = v;
}

/**
 * 折半查找的入口函数
 * @param a 
 * @param size 
 */
void Main_halfInsertSort(int *a, int size){
    for (int i = 0; i < SIZE; ++i) {
        halfInsertSort(a,i,a[i]);
    }

    for (int i = 0; i < 13; ++i) {
        printf("%d ", a[i]);
    }
}

int main(int argc, char *argv[]) {
    int a[SIZE] = {23, 4, 56, 7, 8, 9, 8, 76, 5, 4, 34, 5, 6};
    
//    折半插入排序
    printf("折半插入排序:\n");
    Main_halfInsertSort(a, SIZE);
    printf("\n");

    return 0;
}
```

**设计难点：**

1. 二分结束后正确的插入位置 **right+1**

![image-20220313135411519](https://gitee.com/ah_zhu/blogimage/raw/master/img/image-20220313135411519.png)

2. 向后挪

```c
for (int i = size-1; i >= right+1; --i) {
        a[i+1] = a[i];
}
```

插入

```c
a[right+1] = v;
```



**Go实现**

```go
func halfInsertSort(a *[len(a1)]int, size int, value int) {

	left := 0
	right := size - 1
	var mid, i int

	//1.二分查找
	for left <= right {
		mid = (left + right) / 2

		if value > a[mid] {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}

	//此时待插入的点为 right + 1

	//2.向后挪动
	for i = size - 1; i >= right+1; i-- {
		a[i+1] = a[i]
	}
	//2.1 插入
	a[right+1] = value
}

func Main_halfInsertSort(a *[len(a1)]int, size int){
	for i := 0; i < size; i++ {
		halfInsertSort(a,i,a[i])
	}

	// 打印
	for _, v := range a {
		fmt.Printf("%d ", v)
	}
}

func main() {
   Main_halfInsertSort(&a1, len(a1))
}
```

```
1 2 2 3 5 6 6 8 9 23 59 92 94 
```

## 希尔排序



# 交换排序

## 冒泡排序

## 快速排序



# 选择排序

## 简单选择排序

## 堆排序



# 归并排序

# 基数排序

# 外部排序

# 排序算法分析与应用