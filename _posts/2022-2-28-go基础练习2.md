---
title: go基础练习2
tags: go练习题
article_header:
  type: cover
  image:
    src: /img/go/background.png
---

**一些练习题，简单回顾一下六到八节的内容**

排序、

一起学习:smiley:



<!--more-->



# 排序

```go
package main

import (
    "fmt"
    "sort"
)

func main() {

    strs := []string{"c", "a", "b"}
    sort.Strings(strs)//数组排序
    fmt.Println("Strings:", strs)

    ints := []int{7, 2, 4}
    sort.Ints(ints)//数组排序
    fmt.Println("Ints:   ", ints)

    //是否排好序
    s := sort.IntsAreSorted(ints)
    fmt.Println("Sorted: ", s)
}
```

```
Strings: [a b c]
Ints:    [2 4 7]
Sorted:  true
```

## 使用函数自定义排序

有时候，我们可能想根据自然顺序以外的方式来对集合进行排序。 

例如，假设我们要按字符串的长度而不是按字母顺序对它们进行排序。 

这儿有一个在 Go 中自定义排序的示例。

```go
package main

import (
    "fmt"
    "sort"
)
// byLength 类型，它只是内建类型 []string 的别名。
type byLength []string//这里不想C语言是起别名，这里是定义了新的类型

/*
ort.Interface 接口的 Len、Less 和 Swap 方法
*/
func (s byLength) Len() int {
    return len(s)
}
func (s byLength) Swap(i, j int) {
    s[i], s[j] = s[j], s[i]
}
//Less 将控制实际的自定义排序逻辑。
func (s byLength) Less(i, j int) bool {
    return len(s[i]) < len(s[j])
}

func main() {
    fruits := []string{"peach", "banana", "kiwi"}
    //将切片 fruits 强转为 byLength 类型的切片
    sort.Sort(byLength(fruits))
    fmt.Println(fruits)
}
```

```
[kiwi peach banana]
```

别名与新类型

```go
type MyInt1 int   //新的类型
type MyInt2 = int //别名
```

